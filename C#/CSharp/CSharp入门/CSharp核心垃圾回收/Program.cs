using System;

namespace CSharp核心垃圾回收
{


    #region 垃圾回收机制：英文简写GC（Garbage Collector）
    /*
        1，概念:垃圾回收的过程就是在遍历 堆（Heap）上动态分配的所有对象 
                --通过识别它们是否被引用来确定哪些对象是垃圾，不被引用就是垃圾，哪些对象仍被使用
                --所谓的垃圾就是没有被任何变量，对象引用的内容，垃圾就需要被回收释放


        2，垃圾回收的有很多算法（了解），比如引用计数（Reference Counting）、标记清除（Mark Sweep）、标记整理（Mark Compact）、复制集合（Copy Collection）


        3,注意点：
        //GC（垃圾回收）只负责堆（Heap）内存的垃圾回收
        //引用类型都是存在堆（Heap）中的，所以它的分配和释放都通过垃圾回收机制来管理

        //而栈（Stack）上的内存都是系统自动管理的
        //值类型再栈上分配内存，他们又自己的生命周期，会自动管理和释放

    */


    //面试喜欢问
    #region 垃圾回收机制的大概原理
    //0代内存  1代内存  2代内存
    //代的概念：
    //代是垃圾回收机制使用的一种算法（分代算法）


    //下面是垃圾回收机制的过程：
    //1,新分配的对象（new 对象），首先会被分配到0代内存中
    //2,一直分配，系统会去检查0代内存是否满了，当添加一个对象是这时系统检查0代内存满了
    //3,那么垃圾回收机制进行步骤
    //3.1--标记对象，从根（静态字段，方法参数）开始来检查引用对象。标记为可达对象（被引用还被使用的对象）和不可达对象（垃圾）
    //3.2--搬迁对象压缩堆,把不可达对象（垃圾）释放掉，把可达对象搬到1代内存中，因为这些可达对象间是不相连的，垃圾回收还会把
    //--这些对象压缩到一起（修改他们的引用地址，并且他们的引用地址连起来）

    //4，当1代内存也满了，那么不仅1代内存的对象进行步骤3的操作，连0代内存也执行
    //5,大对象（83k左右以上）通常直接被放置2代内存，因为进行垃圾回收是消耗cpu算力资源的，他放到0代总会被搬到2代
    //所以目的为了减少性能损耗，提供性能


    //GC，一般系统自动触发。
    //内存满了GC会触发，GC触发会卡顿（消耗cpu耗时间）,所以需要在特定时间手动GC，减少用户不良体验
    //一般游戏中GC时间都在loading时，用这短暂时间GC是最好的，不会影响用户体验
    //一般不频繁调用消耗cpu性能
    //GC手动触发：GC.Collect()







    #endregion



    #endregion



    class User { }
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
            User u = new User();

            GC.Collect();

        }
    }
}
